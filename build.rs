use std::{
	env,
	fs::{self, File},
	io::Write,
	path::Path
};

/// Extract token inside parentheses (like "foo" or "crate::mod::foo")
fn extract_inner_token(s: &str) -> Option<String> {
	if let Some(pos) = s.find(')') {
		let inner = &s[..pos];
		let t = inner.trim();
		let t = t.trim_end_matches([',', ';']).trim();
		if !t.is_empty() {
			return Some(t.to_string());
		}
	}
	None
}

fn search_files_recursively(path: &Path) -> Vec<String> {
	let mut symbols: Vec<String> = Vec::new();

	for entry in fs::read_dir(path).expect("failed to read dir") {
		let entry = entry.expect("read_dir entry");
		let path = entry.path();
		if path.is_file()
			&& let Some(ext) = path.extension()
				&& ext == "rs" {
					let file = fs::read_to_string(&path).unwrap_or_default();

					let needle = "create_test!(";
					for (pos, _) in file.match_indices(needle) {
						let start = pos + needle.len();
						let rest = &file[start..];

						if let Some(inner) = extract_inner_token(rest) {
							// compute line number where create_test appears
							let prefix = &file[..pos];
							let line_number = prefix.chars().filter(|c| *c == '\n').count() + 1;

							let token = inner.trim();

							// determine exported symbol name exactly as your macro does
							// - for simple identifier forms (no "::"), macro uses
							//   "__kernel_test_<ident>_<line>"
							// - for path forms, macro uses "__kernel_test_<line>"
							let sym = if token.contains("::") || token.starts_with("crate::") {
								format!("__kernel_test_{}", line_number)
							} else {
								format!("__kernel_test_{}_{}", token, line_number)
							};

							symbols.push(sym);
						}
					}
				}
		if path.is_dir() {
			symbols.extend(search_files_recursively(path.as_path()));
		}
	}

	symbols
}

fn main() {
	let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");

	let src = Path::new("src");

	let symbols = search_files_recursively(src);

	let out_path = Path::new(&out_dir).join("tests_registry.rs");
	let mut f = File::create(&out_path).expect("could not create tests_registry.rs in OUT_DIR");

	writeln!(f, "#[cfg(feature = \"test\")]").unwrap();
	writeln!(f, "pub(crate) mod __generated_test_registry {{").unwrap();
	writeln!(f, "    // auto-generated by build.rs").unwrap();
	writeln!(f, "    use crate::utils::ktest::TestDescriptor;").unwrap();

	// Define a wrapper newtype that implements Sync
	writeln!(f, "    #[repr(transparent)]").unwrap();
	writeln!(
		f,
		"    pub struct TestDescriptorPtrArray<const N: usize>(pub [*const TestDescriptor; N]);"
	)
	.unwrap();
	writeln!(
		f,
		"    unsafe impl<const N: usize> Sync for TestDescriptorPtrArray<N> {{}}"
	)
	.unwrap();

	// single extern block with all discovered symbols
	writeln!(f, "    unsafe extern \"C\" {{").unwrap();
	for s in &symbols {
		writeln!(f, "        pub static {}: TestDescriptor;", s).unwrap();
	}
	writeln!(f, "    }}").unwrap();

	// Use the wrapper for the static
	writeln!(f, "    #[used]").unwrap();
	writeln!(f, "    #[unsafe(no_mangle)]").unwrap();
	writeln!(f, "    pub static __kernel_test_registry_refs: TestDescriptorPtrArray<{}> = TestDescriptorPtrArray([", symbols.len()).unwrap();

	for s in &symbols {
		writeln!(
			f,
			"       unsafe {{ &{sym} as *const TestDescriptor }},",
			sym = s
		)
		.unwrap();
	}

	writeln!(f, "    ]);").unwrap();
	writeln!(f, "}}").unwrap();

	println!(
		"cargo:warning=generated {} test extern refs -> {}",
		symbols.len(),
		out_path.display()
	);
}
